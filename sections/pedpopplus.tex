\section{$\pedpopcomm$}

$\pedpopcomm$ is a modification of $\pedpop$ in which three extra rounds of communications are added.
This protocol could either be used as a DKG or as a Key Resharing scheme.
We depict the protocol in Figure~\ref{fig:pedpopplus} and Figure~\ref{fig:pedpopplus-reshare}.

We require an online-extractable non-interactive zero-knowledge proof (NIZK).
The relation that we must prove is simply the Schnorr relation;
that the prover knows the discrete logarithm to the commitment.
Figure~\ref{fig:pedpopplus} simply refers to this relation as $\SchnorrR$;
applying the non-interactive proof straight-line compiler given by Chen et al.~\cite{ChenDGMSS25} gives online-extractability and hence UC security.

\subsection{Key Generation}\label{sec:key-generation}
In Round 0, a participant performs necessary checks to  picks a random session identifier and broadcasts it.
It then receives the broadcast session identifiers from it's peers and hashes all identifiers into one single string in Round 1.
The participant picks $t+1$ random coefficients. Each coefficient $a$ is committed to by computing $g^a$.
The vector of commitments is hashed and sent to all the peers.
Still in Round 1, the participant gives a proof of knowledge of $\alpha$ $g^\sk$  using the Schnorr signature scheme.
In Round 2, the participant receives the hash values from its peers, stores them, and broadcasts the commitment vector along with the Schnorr signature.
In Round 2, each participant evaluates the polynomial generated by the picked coefficients.
The number of evaluations is equal to the number of participants currently contributing to the protocol.
It then verifies the correctness of the signature and the well-formedness of the received hash value then privately shares each computed polynomial evaluation with the corresponding peer participant.
Round 3 receives the evaluations and verifies their correctness, then computing the master verification key and the private signing key share.
Finally, if all the checks pass, then a success string is broadcast.
In Round 4, each participant collects $n$ success strings,
else the participant aborts.

\subsection{Key Resharing}\label{sec:key-resharing}
Key Resharing using $\pedpopcomm$ is similar to key generation,
with the exception that participants distribute sub-shares of their secret share,
as opposed to a random value, as is the case for key generation.

\paragraph{Allowing New Joiners}
It is possible to allow new participants to join the coalition of signers,
in such a way that these participants also contribute to the total randomness of the shares,
while keeping the original secret key the same.

We likewise show this approach in Figure~\ref{fig:pedpopplus-reshare}.

In Round 1, we distinguish two cases: if the participant running the protocol is part of the new joining participants, then it simply sets the first coefficient (denoted with $\sk$) to zero; otherwise, it linearizes its old share of secret key using
Lagrange coefficients generated for common parties between old and new participants sets.
More specifically, the function $\linearize_k(\oldsk, I)$ computes the product
\[
\linearize_k(\oldsk, I)\coloneqq \oldsk \cdot \prod_{\substack{i\in I\\ i\neq k}} \frac{i}{i-k}
\]

In Round 4, the computed verification key is checked to match the same old public key given as input to the protocol.
Checking such invariant is due to the fact that honest new participants shall not affect the value of the old verification key as their initial private shares are set to zero.

\begin{figure}[!ht]
\centering
\begin{pchstack}[boxed,center,space=1em]
\begin{pcvstack}
\procedure{$\KeyGen_0(k, t, n)$}{
\require n > 2\\
\require k\in \set{n}\\
\require t\leq n\\
\sid_i \rgets \zo^\lambda \\
\sendbroadcast((\sid_i)) \\
}
\procedure{$\KeyGen_1(\sid_1, \ldots, \sid_n)$}{
\sid \gets \Hash_1(\sid_1, \ldots, \sid_n) \\
(\alpha, a_1, \ldots, a_t) \rgets \Zq^t \\
A_0 \gets g^{\alpha} \\
\pcfor i \in \set{t} \pcdo \\
\quad A_i \gets g^{a_i} \\
C_k \gets (A_0, \ldots, A_t)\\
H_k \gets \Hash_2(k, C_k, \sid) \\
\gamma_k \gets (\sid, k, C_k[0]) \\
\pi_k \rgets \SchnorrR[\Hash_3].\Sign(\alpha, \gamma_k) \\
\pcfor i \in \set{n}\\
\quad \send(i, H_k) \\
}
\procedure{$\KeyGen_2(\{H_i\}_{i\in\set{n}})$}{
\sendbroadcast(C_k, \pi_k) \\
}
\end{pcvstack}
\begin{pcvstack}
\procedure{$\KeyGen_3(\{C_i, \pi_i\}_{i\in\set{n}})$}{
\pcfor j \in \set{n} \\
\quad f_k(j) \gets \alpha + \sum_{i=1}^t a_i j^i \\
\pcfor i \in \set{n}, i \neq k \\
\quad \gamma_i \gets (\sid, k, C_i[0]) \\
\quad \require \SchnorrR[\Hash_3].\Verify(C_i[0], \gamma_i, \pi_i) \\
\quad \require \Hash_2(\sid, i, C_i) = H_i\\
\quad \send(i, f_k(i)) \\
}
\procedure{$\KeyGen_4(\{f_i(k)\}_{i\in\set{n}})$}{
\pcfor i \in \set{n}, i \neq k \\
\quad \require g^{f_i(k)} = \prod_{j=0}^t C_i[j]^{k^j} \\
% \pcfor i \in \set{n} \\
% \quad \pk_i \gets \prod_{j=1}^n \prod_{\ell=0}^{t-1} C_j[\ell]^{i^\ell}  \\
\sk_k \gets \sum_{i=1}^n f_i(k) \\
\pk \gets \prod_{i=1}^n C_i[0] \\
\sendbroadcast(\text{``success'', $\sid$})\\
}
\procedure{$\KeyGen_5(\{s_i\}_{i\in\set{n}})$}{
\pcfor i \in \set{n}, i \neq k \\
\quad \require s_i = \text{(``success'', $\sid$)} \\
\pcreturn (\pk, \sk_k) \\
}
\end{pcvstack}
\end{pchstack}
\caption{The five-round DKG $\pedpopcomm$.
See Section~\ref{sec:comm-model} for definitions of $\send$ and $\sendbroadcast$.}
\label{fig:pedpopplus}
\end{figure}
